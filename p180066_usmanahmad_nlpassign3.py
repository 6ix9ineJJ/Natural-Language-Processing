# -*- coding: utf-8 -*-
"""P180066_UsmanAhmad_NLPassign3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IRMX9tCMCUmAdHNqe1yYuihurjbaV0re
"""



from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/Colab Notebooks

import re
import math
import string
from collections import Counter

# Step 1: Train a unigram model using data.txt
with open('data.txt', 'r') as f:
    data = f.read().lower().split()
    unigram_counts = {}
    for word in data:
        for char in word:
            if char in unigram_counts:
                unigram_counts[char] += 1
            else:
                unigram_counts[char] = 1

    total_count = sum(unigram_counts.values())
    unigram_probabilities = {char: count/total_count for char, count in unigram_counts.items()}

# Step 2: Create error model tables
insertions = {}
deletions = {}
substitutions = {}
transpositions = {}

# Open the misspellings file
with open('misspellings.txt', 'r') as f:
    for line in f:
        try:
            original, misspelling = line.strip().split('\t')
            if len(original) == len(misspelling):
                # substitution
                for i, c in enumerate(original):
                    if c != misspelling[i]:
                        substitutions[c+misspelling[i]] = substitutions.get(c+misspelling[i], 0) + 1
                
                # transposition
                for i in range(len(original)-1):
                    if original[i] != misspelling[i] and original[i+1] != misspelling[i+1] and original[i] == misspelling[i+1] and original[i+1] == misspelling[i]:
                        transpositions[original[i:i+2]] = transpositions.get(original[i:i+2], 0) + 1
                
            elif len(original) == len(misspelling) - 1:
                # insertion
                for i, c in enumerate(misspelling):
                    if original[i] != misspelling[i]:
                        insertions[original[i]+c] = insertions.get(original[i]+c, 0) + 1
                
            elif len(original) == len(misspelling) + 1:
                # deletion
                for i, c in enumerate(original):
                    if misspelling[i] != original[i]:
                        deletions[c] = deletions.get(c, 0) + 1
        except ValueError:
            # skip lines that don't have the correct format
            continue

# Step 3: Create function to calculate P(x|w)
def P_x_given_w(x, w):
    if len(x) != len(w):
        return 0
    log_prob = 0
    for i in range(len(x)):
        if x[i] != w[i]:
            key = w[i] + x[i]
            if key in substitutions:
                log_prob += math.log(substitutions[key]/unigram_counts[w[i]])
            else:
                return 0
    return math.exp(log_prob)

print(misspellings)

# Step 4: Create function to generate candidate words
def generate(word, vocab):
    # Set of candidate words that are one edit away from the given word
    candidates = set()

    # Generate all possible insertions
    for i in range(len(word)+1):
        for char in string.ascii_lowercase:
            candidate = word[:i] + char + word[i:]
            if candidate in vocab:
                candidates.add(candidate)

    # Generate all possible deletions
    for i in range(len(word)):
        candidate = word[:i] + word[i+1:]
        if candidate in vocab:
            candidates.add(candidate)

    # Generate all possible substitutions
    for i in range(len(word)):
        for char in string.ascii_lowercase:
            candidate = word[:i] + char + word[i+1:]
            if candidate in vocab:
                candidates.add(candidate)

    # Generate all possible transpositions
    for i in range(len(word)-1):
        candidate = word[:i] + word[i+1] + word[i] + word[i+2:]
        if candidate in vocab:
            candidates.add(candidate)

    return candidates

with open('data.txt', 'r') as f:
    words = set(f.read().split())

word = 'goig'
candidates = generate(word, words)

print(candidates)







